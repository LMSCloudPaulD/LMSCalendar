{"version":3,"file":"getOverlappingEntitiesIndices.js","sourceRoot":"","sources":["../../src/utils/getOverlappingEntitiesIndices.ts"],"names":[],"mappings":"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","sourcesContent":["import partitionOverlappingIntervals from './partitionOverlappingIntervals.js';\n\nexport default function getOverlappingEntitiesIndices(partitions: Interval[][]): Grading[] {\n  /** First we determine all non-overlapping partitions and save their indices.\n   *  Indices go into the index portion of the resolving objects and we add\n   *  a depth of 0 to indicate, that this is a full-width element.\n   */\n\n  const result = partitions.reduce(\n    (accumulator: Grading[], partition, index: number) =>\n      partition.length === 1\n        ? [\n            ...accumulator,\n            {\n              index: [partitions.slice(0, index)].flatMap(\n                (item) => item.flat().length\n              )[0],\n              depth: 0,\n              group: index,\n            },\n          ]\n        : [...accumulator],\n    []\n  );\n\n  /** Then we filter the non-overlapping partitions out */\n  const _partitions = partitions\n    .map((partition, index) =>\n      partition.map((item, _index) => ({\n        ...item,\n        index:\n          [partitions.slice(0, index)].flatMap(\n            (item) => item.flat().length\n          )[0] + _index,\n        group: index,\n      }))\n    )\n    .filter((partition) => partition.length > 1);\n\n  /** For each of the remaining partitions we have to check how deeply they overlap.\n   *  TODO: Add indictor for partition group; document...\n   */\n  let depth = 0;\n  let openGroup: number | undefined = Math.min(\n    ...[..._partitions.map((partition) => partition[0].group)]\n  );\n  function recursiveBubbleSort({partitions, isNested = false}: { partitions: Partition[][], isNested?: Boolean}) {\n    depth = isNested ? (depth += 1) : 0;\n    partitions.forEach((partition: Partition[]) => {\n      const {group} = partition[0];\n      if (openGroup !== group) {\n        depth = 0;\n      }\n      openGroup = group;\n\n      const delta = [...partition.map(({start, end}: Partition) => end - start)];\n      const maxDelta = Math.max(...delta);\n      const indexMaxDelta: number = delta.indexOf(maxDelta);\n\n      result.push({\n        index: partition[indexMaxDelta].index as number,\n        depth,\n        group: partition[indexMaxDelta].group as number,\n      });\n\n      partition.splice(delta.indexOf(maxDelta), 1);\n\n      recursiveBubbleSort({\n        partitions: partitionOverlappingIntervals(partition as Interval[]) as Partition[][],\n        isNested: true,\n      });\n    });\n  }\n\n  recursiveBubbleSort({partitions: _partitions as Partition[][]});\n\n  return result.sort((a, b) => a.index - b.index);\n}\n"]}